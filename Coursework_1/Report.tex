\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage[bookmarks]{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\definecolor{col_light_grey}{rgb}{0.9, 0.9, 0.9}
\definecolor{col_green}{rgb}{0,0.6,0}
\definecolor{col_grey}{rgb}{0.5,0.5,0.5}
\definecolor{col_mauve}{rgb}{0.58,0,0.82}

\lstset{
  backgroundcolor=\color{col_light_grey},
  basicstyle=\footnotesize,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{col_green},
  escapeinside={\%*}{*)},
  keywordstyle=\color{blue},
  stringstyle=\color{col_mauve},
  tabsize=2,
}
\lstset{language=bash}

\hypersetup{
  pdfinfo={
    Title={COMP1204: Unix Coursework},
    Author={Huw Jones},
  },
  colorlinks=false,
  pdfborder=0 0 0,
}

\pagestyle{headings}

\author{Huw Jones \\27618153}
\title{COMP1204: Unix Coursework}

\begin{document}
\maketitle
\newpage

\section{Scripts}

%	3.1.1
%	Question 1
%
\subsection{Count Reviews: Single File}

\subsubsection{Source}
\lstinputlisting{Q1/countreviews.sh}


\subsubsection{Explanation}

\begin{lstlisting}
grep -c "<Author>" $1
\end{lstlisting}
As every review has an author, it made sense to search for the ``\textless Author\textgreater" string.
Using the ``-c" argument for grep returns a search count, rather than the string of occurrences.
``\$1" is used to get the first (real) argument when the script is executed on the command line.

%	3.1.1
%	Question 2
%
\subsection{Count Reviews: Directory}

\subsubsection{Source}
\lstinputlisting{Q2/countreviews.sh}


\subsubsection{Explanation}

\begin{lstlisting}
function getReviewCount () {
	grep -c "<Author>" $1
}
\end{lstlisting}
This function returns the number of reviews in a hotel data file.

\begin{lstlisting}
if [ -d $1 ]
then

...
fi
\end{lstlisting}
This checks whether the argument passed was a directory, and if so, execute the appropriate code.

\begin{lstlisting}
for file in $1/*
do
	getReviewCount $file
done;
\end{lstlisting}
This section is executed if the argument passed as a directory.
It iterates over the files in the directory, then calls the ``getReviewCount" function for each file.

\begin{lstlisting}
else
	getReviewCount $1
fi
\end{lstlisting}
This code is executed if the argument passed to the script is not a directory.
It executes the ``getReviewCount" as it should normally do for a file. \newline \newline
This script works for both 3.1.1: 1 and 2.

%	3.1.1
%	Question 3
%
\newpage
\subsection{Count Reviews: Sorted}
\subsubsection{Source}
\lstinputlisting{Q3/countreviews.sh}

\subsubsection{Explanation}
\begin{lstlisting}
reviewCount=""
\end{lstlisting}
Initialises variable ``reviewCount" to an empty string.

\begin{lstlisting}
hotelName=${file#$1/}
\end{lstlisting}
This removes the directory prefix from ``\$1" (from when the script was called) from ``\$file" and assigns it to ``hotelName".

\begin{lstlisting}
hotelName=${hotelName%.dat}
\end{lstlisting}
Removes the ``.dat"" suffix from ``hotelName" and assigns it to ``hotelName".

\begin{lstlisting}
currentCount="$(getReviewCount $file) $hotelName"
\end{lstlisting}
Sets ``currentCount" to the output of ``getReviewCount" with the hotel name appended to it. This makes it easier to use sort.

\begin{lstlisting}
reviewCount="$reviewCount"$'\n'"$currentCount"
\end{lstlisting}
Appends ``currentCount" to the ``reviewCount" using a newline so we can maintain 1 hotel per line.

\begin{lstlisting}
echo -e "$reviewCount" | sort -nr | awk '{print $2 " " $1}'
\end{lstlisting}
Echoes the contents of ``reviewCount" to sdtOut whilst maintaining escape characters.
The contents of ``reviewCount" is then piped into the stdIn of sort, which reverse sorts the hotel list by number of reviews.
Finally, awk prints out the sorted list in the format [hotel] [review count].
The list was originally stored as [review count] [hotel] as this makes it easier to use sort as we don't have to specify a sort column.
Using awk to print out the list as required was child's play.

%	3.1.2
%	Hypothesis Testing Script
%
\newpage
\subsection{Average Reviews}
\subsubsection{Source}
\lstinputlisting{averagereviews.sh}

\newpage
\subsubsection{Explanation}
\begin{lstlisting}
# Gets average score to 1dp
function averageScore() {
	t=$1
	n=$2
	
	mean=$((t/n))
	dp=$(( 10 * (t % n) / n ))
	
	echo "$mean.$dp"
}
\end{lstlisting}
This function prints the result of $\$1 / \$2 $ to stdOut.
As most UNIX shells only deal with integer arithmetic, a method that would produce a mean to 1 decimal place was required.
It uses the modulo operator ``\%" to calulate the remainder, then, by multiplying the remainder by 10 and dividing by the number of reviews, it produces an integer of the first decimal place.
This can then be concatenated onto the end of the original, integer, mean.

\begin{lstlisting}
# Gets the sum of all review scores
function getTotalScore() {
	Scores=$(grep "<Overall>" $1)
	TotalScore=0
	while read -r line; do
		TotalScore=$((TotalScore + ${line:(-1)}))
	done <<< "$Scores"
	echo $TotalScore
}
\end{lstlisting}
This function calculates the total of all the review scores ($\sum x$).
It uses grep to filter the lines that contain the overall score (\textless Overall\textgreater).
Then, it iterates over each individual score line.
As the scores are out of a maximum of 5, the last character of the line is the score.
Using bash string formatting, the last character is cut out, and added to the ``TotalScore".
The total score is then output to stdOut.

\begin{lstlisting}
# Gets the average review of the hotel
function getAverageScore() {
	HotelFile=$1
	
	ReviewCount=$(getReviewCount $HotelFile)
	TotalScore=$(getTotalScore $HotelFile)
	echo $(averageScore $TotalScore $ReviewCount)
}
\end{lstlisting}
This function uses the results of two of previous functions (getReviewCount and getTotalScore) and passes them to ``averageScore".
The result of ``averageScore" is then printed to stdOut.

\begin{lstlisting}
# Gets the hotel ID from hotel file
function getTrimmedHotelFile() {
	filePath=$1
	fileName=$2
	hotelName=${fileName#$filePath/}
	hotelName=${hotelName%.dat}
	echo $hotelName
}
\end{lstlisting}
This function gets the hotel ID in the form of hotel\_xxxxxx.
It uses string manipulation to remove the directory path from the prefix of the filename
Then it removes the .dat file extension.
Again, the output of this function is printed to stdOut.

\begin{lstlisting}
# Checks argument passed was a directory
if [ -d $1 ]
then
	# Loops through all files and prints HOTEL_ID AVERAGE_REVIEW
	for file in $1/*
	do
		echo $(getTrimmedHotelFile $1 $file) $(getAverageScore $file)
	done
else
	echo "$1 is not a valid directory."
fi
\end{lstlisting}
This part of the script checks a directory was passed as the first argument.
If a directory wasn't passed as the first argument, the script notifies the user, then terminates.
Otherwise, it loops over every file in the data directory, then prints the hotel ID with the average review score.


\newpage
\section{Hypothesis Testing}

\newpage
\section{Discussion}


\end{document}