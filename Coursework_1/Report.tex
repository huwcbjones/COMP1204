\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage[bookmarks]{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\definecolor{col_light_grey}{rgb}{0.9, 0.9, 0.9}
\definecolor{col_green}{rgb}{0,0.6,0}
\definecolor{col_grey}{rgb}{0.5,0.5,0.5}
\definecolor{col_mauve}{rgb}{0.58,0,0.82}

\lstset{
  backgroundcolor=\color{col_light_grey},
  basicstyle=\footnotesize,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{col_green},
  escapeinside={\%*}{*)},
  keywordstyle=\color{blue},
  stringstyle=\color{col_mauve},
  tabsize=2,
}
\lstset{language=bash}

\hypersetup{
  pdfinfo={
    Title={COMP1204: Unix Coursework},
    Author={Huw Jones},
  },
  colorlinks=false,
  pdfborder=0 0 0,
}

\pagestyle{headings}

\author{Huw Jones \\27618153}
\title{COMP1204: Unix Coursework}

\begin{document}
\maketitle
\newpage

\section{Scripts}

%	3.1.1
%	Question 1
%
\subsection{Count Reviews: Single File}

\subsubsection{Source}
\lstinputlisting{1-1/countreviews.sh}


\subsubsection{Explanation}

\begin{lstlisting}
grep -c "<Author>" $1
\end{lstlisting}
As every review has an author, it made sense to search for the ``\textless Author\textgreater" string.
Using the ``-c" argument for grep returns a search count, rather than the string of occurrences.
``\$1" is used to get the first (real) argument when the script is executed on the command line.

%	3.1.1
%	Question 2
%
\subsection{Count Reviews: Directory}

\subsubsection{Source}
\lstinputlisting{1-2/countreviews.sh}


\subsubsection{Explanation}

\begin{lstlisting}
function getReviewCount () {
	grep -c "<Author>" $1
}
\end{lstlisting}
This function returns the number of reviews in a hotel data file.

\begin{lstlisting}
if [ -d $1 ]
then

...
fi
\end{lstlisting}
This checks whether the argument passed was a directory, and if so, execute the appropriate code.

\begin{lstlisting}
for file in $1/*
do
	getReviewCount $file
done;
\end{lstlisting}
This section is executed if the argument passed as a directory.
It iterates over the files in the directory, then calls the ``getReviewCount" function for each file.

\begin{lstlisting}
else
	getReviewCount $1
fi
\end{lstlisting}
This code is executed if the argument passed to the script is not a directory.
It executes the ``getReviewCount" as it should normally do for a file. \newline \newline
This script works for both 3.1.1: 1 and 2.

%	3.1.1
%	Question 3
%
\newpage
\subsection{Count Reviews: Sorted}
\subsubsection{Source}
\lstinputlisting{1-3/countreviews.sh}

\subsubsection{Explanation}
\begin{lstlisting}
reviewCount=""
\end{lstlisting}
Initialises variable ``reviewCount" to an empty string.

\begin{lstlisting}
function getTrimmedHotelFile() {
	echo $1 | sed -e 's:^[/a-zA-Z_0-9\-]*\/::' -e 's:.dat::'
}
\end{lstlisting}
This functions uses sed substitution to remove all directory prefixes up to the last forward slash in the file path (/) from ``\$file".
It then uses another substitution to remove the .dat extension.
Then, it assigns the result to ``hotelName".

The regex works as follows.
\begin{lstlisting}
^
\end{lstlisting}
Matches from the start of the string
\begin{lstlisting}
^[/a-zA-Z_0-9\-]*
\end{lstlisting}
Matches 0 or more all alphanumeric characters, dashes, forward slashes and underscores from the start of the string.
\begin{lstlisting}
\/
\end{lstlisting}
Matches a forward slash. The backslash is used to escape it as forward slash is a special character.

\begin{lstlisting}
^[/a-zA-Z_0-9\-]*\/
\end{lstlisting}
So, overall this regex matches all directories up to the last slash before the file name.
This allows the script to remove the directory prefix.
If sed supported ``\textbackslash s\textbackslash S", I would have used that instead of the alphanumeric mess that is currently used.

\begin{lstlisting}
currentCount="$hotelName"$'\t'"$(getReviewCount $file)"
\end{lstlisting}
Sets ``currentCount" to the hotel ID and the output of ``getReviewCount".
The tab is used to make the output prettier than just using spaces.

\begin{lstlisting}
reviewCount="$reviewCount"$'\n'"$currentCount"
\end{lstlisting}
Appends ``currentCount" to the ``reviewCount" using a newline so we can maintain 1 hotel per line.

\begin{lstlisting}
echo -e "$reviewCount" | sort -k2nr
\end{lstlisting}
Echoes the contents of ``reviewCount" to sdtOut whilst maintaining escape characters.
The contents of ``reviewCount" is then piped into the stdIn of sort, which reverse sorts the hotel list by number of reviews.
Sort takes a ``-k" argument that is used to specify the sort column.
Here, ``-k2nr" sorts the string by the second column (number of reviews)(``k2"), as a numeric type (``n"), reversely (``r") (to sort by the greater number first).

%	3.1.2
%	Hypothesis Testing Script
%
\newpage
\subsection{Average Reviews}
\subsubsection{Source}
\lstinputlisting{2-1/averagereviews.sh}

\newpage
\subsubsection{Explanation}
\begin{lstlisting}
# Gets average score to 1dp
function averageScore() {
	t=$1
	n=$2
	
	mean=$((t/n))
	dp=$(( 10 * (t % n) / n ))
	
	echo "$mean.$dp"
}
\end{lstlisting}
This function prints the result of $\$1 / \$2 $ to stdOut.
As most UNIX shells only deal with integer arithmetic, a method that would produce a mean to 1 decimal place was required.
It uses the modulo operator ``\%" to calulate the remainder, then, by multiplying the remainder by 10 and dividing by the number of reviews, it produces an integer of the first decimal place.
This can then be concatenated onto the end of the original, integer, mean.

\begin{lstlisting}
# Gets the sum of all review scores
function getTotalScore() {
	Scores=$(grep "<Overall>" $1 | sed -e 's:<Overall>::' -e 's:\r::')
	TotalScore=0
	while read -r line; do
		TotalScore=$((TotalScore + line))
	done <<< "$Scores"
	echo $TotalScore
}
\end{lstlisting}
This function calculates the total of all the review scores ($\sum x$).
It uses grep to filter the lines that contain the overall score (\textless Overall\textgreater).
Then, pipes the grep output to a sed substitution that removes ``\textless Overall\textgreater".
Next, it adds the line (which should be the rating) to the ``TotalScore".
The total score is then output to stdOut.

\begin{lstlisting}
# Gets the average review of the hotel
function getAverageScore() {
	HotelFile=$1
	
	ReviewCount=$(getReviewCount $HotelFile)
	TotalScore=$(getTotalScore $HotelFile)
	echo $(averageScore $TotalScore $ReviewCount)
}
\end{lstlisting}
This function uses the results of two of previous functions (getReviewCount and getTotalScore) and passes them to ``averageScore".
The result of ``averageScore" is then printed to stdOut.

\begin{lstlisting}
# Checks argument passed was a directory
if [ -d $1 ]
then
	# Loops through all files and prints HOTEL_ID AVERAGE_REVIEW
	for file in $1/*
	do
		currentHotel="$(getTrimmedHotelFile $file)"$'\t'"$(getAverageScore $file)"
		hotels="$hotels"$'\n'"$currentHotel"
	done
	
	# Sort hotels by second column (rating)
	echo -e "$hotels" | sort -k2nr
else
	echo "$(getTrimmedHotelFile $1) $(getAverageScore $1)"
fi
\end{lstlisting}
This part of the script checks a directory was passed as the first argument.
Otherwise, it loops over every file in the data directory, then prints the hotel ID with the average review score, sorted by average review.


\newpage
\section{Hypothesis Testing}

\newpage
\section{Discussion}


\end{document}
